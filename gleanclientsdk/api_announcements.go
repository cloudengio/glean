/*
Glean Client API - Platform Preview

# Introduction These are all the APIs used by Glean to implement the Glean client. These are available as platform preview for implementing a custom client to the Glean system.  # Usage guidelines A subset of these endpoints are also in the developer ready section, which is available for public use. The rest of the endpoints are subject to prior agreement with Glean before usage. Please contact support@glean.com if you would like to use an API that is not currently available in the developer ready section. 

API version: 0.9.0
Contact: support@glean.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package gleanclientsdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// AnnouncementsApiService AnnouncementsApi service
type AnnouncementsApiService service

type ApiCreateannouncementRequest struct {
	ctx context.Context
	ApiService *AnnouncementsApiService
	payload *CreateAnnouncementRequest
	actas *string
	clientVersion *string
	domain *string
	eids *[]int64
}

// Announcement content
func (r ApiCreateannouncementRequest) Payload(payload CreateAnnouncementRequest) ApiCreateannouncementRequest {
	r.payload = &payload
	return r
}

// Email of another user to act as for debugging purposes. Requires sufficient permissions.
func (r ApiCreateannouncementRequest) Actas(actas string) ApiCreateannouncementRequest {
	r.actas = &actas
	return r
}

// The version of the client making the request.
func (r ApiCreateannouncementRequest) ClientVersion(clientVersion string) ApiCreateannouncementRequest {
	r.clientVersion = &clientVersion
	return r
}

// The domain of the top-level page in which the client is being run. For embedded search and NSR, it will be the domain of the embedding page. For sidebar, it will be the domain of the embedding page if it&#39;s a recognized workplace app. For NTP and app.glean.com requests, it will be empty.
func (r ApiCreateannouncementRequest) Domain(domain string) ApiCreateannouncementRequest {
	r.domain = &domain
	return r
}

// List of experiment ids to force for incoming request.
func (r ApiCreateannouncementRequest) Eids(eids []int64) ApiCreateannouncementRequest {
	r.eids = &eids
	return r
}

func (r ApiCreateannouncementRequest) Execute() (*Announcement, *http.Response, error) {
	return r.ApiService.CreateannouncementExecute(r)
}

/*
Createannouncement Create announcement

Creates a textual announcement visible to some set of users based on department and location.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateannouncementRequest
*/
func (a *AnnouncementsApiService) Createannouncement(ctx context.Context) ApiCreateannouncementRequest {
	return ApiCreateannouncementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Announcement
func (a *AnnouncementsApiService) CreateannouncementExecute(r ApiCreateannouncementRequest) (*Announcement, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Announcement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnouncementsApiService.Createannouncement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/createannouncement"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	if r.actas != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actas", r.actas, "")
	}
	if r.clientVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientVersion", r.clientVersion, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.eids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eids", r.eids, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreatedraftannouncementRequest struct {
	ctx context.Context
	ApiService *AnnouncementsApiService
	payload *CreateDraftAnnouncementRequest
	actas *string
	clientVersion *string
	domain *string
	eids *[]int64
}

// Draft announcement content
func (r ApiCreatedraftannouncementRequest) Payload(payload CreateDraftAnnouncementRequest) ApiCreatedraftannouncementRequest {
	r.payload = &payload
	return r
}

// Email of another user to act as for debugging purposes. Requires sufficient permissions.
func (r ApiCreatedraftannouncementRequest) Actas(actas string) ApiCreatedraftannouncementRequest {
	r.actas = &actas
	return r
}

// The version of the client making the request.
func (r ApiCreatedraftannouncementRequest) ClientVersion(clientVersion string) ApiCreatedraftannouncementRequest {
	r.clientVersion = &clientVersion
	return r
}

// The domain of the top-level page in which the client is being run. For embedded search and NSR, it will be the domain of the embedding page. For sidebar, it will be the domain of the embedding page if it&#39;s a recognized workplace app. For NTP and app.glean.com requests, it will be empty.
func (r ApiCreatedraftannouncementRequest) Domain(domain string) ApiCreatedraftannouncementRequest {
	r.domain = &domain
	return r
}

// List of experiment ids to force for incoming request.
func (r ApiCreatedraftannouncementRequest) Eids(eids []int64) ApiCreatedraftannouncementRequest {
	r.eids = &eids
	return r
}

func (r ApiCreatedraftannouncementRequest) Execute() (*Announcement, *http.Response, error) {
	return r.ApiService.CreatedraftannouncementExecute(r)
}

/*
Createdraftannouncement Create a draft announcement

Creates a draft of a textual announcement visible to some set of users based on department and location.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreatedraftannouncementRequest
*/
func (a *AnnouncementsApiService) Createdraftannouncement(ctx context.Context) ApiCreatedraftannouncementRequest {
	return ApiCreatedraftannouncementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Announcement
func (a *AnnouncementsApiService) CreatedraftannouncementExecute(r ApiCreatedraftannouncementRequest) (*Announcement, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Announcement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnouncementsApiService.Createdraftannouncement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/createdraftannouncement"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	if r.actas != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actas", r.actas, "")
	}
	if r.clientVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientVersion", r.clientVersion, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.eids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eids", r.eids, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteannouncementRequest struct {
	ctx context.Context
	ApiService *AnnouncementsApiService
	payload *DeleteAnnouncementRequest
	actas *string
	clientVersion *string
	domain *string
	eids *[]int64
}

// Delete announcement request
func (r ApiDeleteannouncementRequest) Payload(payload DeleteAnnouncementRequest) ApiDeleteannouncementRequest {
	r.payload = &payload
	return r
}

// Email of another user to act as for debugging purposes. Requires sufficient permissions.
func (r ApiDeleteannouncementRequest) Actas(actas string) ApiDeleteannouncementRequest {
	r.actas = &actas
	return r
}

// The version of the client making the request.
func (r ApiDeleteannouncementRequest) ClientVersion(clientVersion string) ApiDeleteannouncementRequest {
	r.clientVersion = &clientVersion
	return r
}

// The domain of the top-level page in which the client is being run. For embedded search and NSR, it will be the domain of the embedding page. For sidebar, it will be the domain of the embedding page if it&#39;s a recognized workplace app. For NTP and app.glean.com requests, it will be empty.
func (r ApiDeleteannouncementRequest) Domain(domain string) ApiDeleteannouncementRequest {
	r.domain = &domain
	return r
}

// List of experiment ids to force for incoming request.
func (r ApiDeleteannouncementRequest) Eids(eids []int64) ApiDeleteannouncementRequest {
	r.eids = &eids
	return r
}

func (r ApiDeleteannouncementRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteannouncementExecute(r)
}

/*
Deleteannouncement Delete announcement

Deletes an existing user-generated announcement.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteannouncementRequest
*/
func (a *AnnouncementsApiService) Deleteannouncement(ctx context.Context) ApiDeleteannouncementRequest {
	return ApiDeleteannouncementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AnnouncementsApiService) DeleteannouncementExecute(r ApiDeleteannouncementRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnouncementsApiService.Deleteannouncement")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deleteannouncement"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return nil, reportError("payload is required and must be specified")
	}

	if r.actas != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actas", r.actas, "")
	}
	if r.clientVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientVersion", r.clientVersion, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.eids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eids", r.eids, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeletedraftannouncementRequest struct {
	ctx context.Context
	ApiService *AnnouncementsApiService
	payload *DeleteAnnouncementRequest
	actas *string
	clientVersion *string
	domain *string
	eids *[]int64
}

// Delete draft announcement request
func (r ApiDeletedraftannouncementRequest) Payload(payload DeleteAnnouncementRequest) ApiDeletedraftannouncementRequest {
	r.payload = &payload
	return r
}

// Email of another user to act as for debugging purposes. Requires sufficient permissions.
func (r ApiDeletedraftannouncementRequest) Actas(actas string) ApiDeletedraftannouncementRequest {
	r.actas = &actas
	return r
}

// The version of the client making the request.
func (r ApiDeletedraftannouncementRequest) ClientVersion(clientVersion string) ApiDeletedraftannouncementRequest {
	r.clientVersion = &clientVersion
	return r
}

// The domain of the top-level page in which the client is being run. For embedded search and NSR, it will be the domain of the embedding page. For sidebar, it will be the domain of the embedding page if it&#39;s a recognized workplace app. For NTP and app.glean.com requests, it will be empty.
func (r ApiDeletedraftannouncementRequest) Domain(domain string) ApiDeletedraftannouncementRequest {
	r.domain = &domain
	return r
}

// List of experiment ids to force for incoming request.
func (r ApiDeletedraftannouncementRequest) Eids(eids []int64) ApiDeletedraftannouncementRequest {
	r.eids = &eids
	return r
}

func (r ApiDeletedraftannouncementRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletedraftannouncementExecute(r)
}

/*
Deletedraftannouncement Delete draft announcement

Deletes an existing user-generated draft announcement.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeletedraftannouncementRequest
*/
func (a *AnnouncementsApiService) Deletedraftannouncement(ctx context.Context) ApiDeletedraftannouncementRequest {
	return ApiDeletedraftannouncementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AnnouncementsApiService) DeletedraftannouncementExecute(r ApiDeletedraftannouncementRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnouncementsApiService.Deletedraftannouncement")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deletedraftannouncement"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return nil, reportError("payload is required and must be specified")
	}

	if r.actas != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actas", r.actas, "")
	}
	if r.clientVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientVersion", r.clientVersion, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.eids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eids", r.eids, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetannouncementRequest struct {
	ctx context.Context
	ApiService *AnnouncementsApiService
	payload *GetAnnouncementRequest
	actas *string
	clientVersion *string
	domain *string
	eids *[]int64
}

// GetAnnouncement request
func (r ApiGetannouncementRequest) Payload(payload GetAnnouncementRequest) ApiGetannouncementRequest {
	r.payload = &payload
	return r
}

// Email of another user to act as for debugging purposes. Requires sufficient permissions.
func (r ApiGetannouncementRequest) Actas(actas string) ApiGetannouncementRequest {
	r.actas = &actas
	return r
}

// The version of the client making the request.
func (r ApiGetannouncementRequest) ClientVersion(clientVersion string) ApiGetannouncementRequest {
	r.clientVersion = &clientVersion
	return r
}

// The domain of the top-level page in which the client is being run. For embedded search and NSR, it will be the domain of the embedding page. For sidebar, it will be the domain of the embedding page if it&#39;s a recognized workplace app. For NTP and app.glean.com requests, it will be empty.
func (r ApiGetannouncementRequest) Domain(domain string) ApiGetannouncementRequest {
	r.domain = &domain
	return r
}

// List of experiment ids to force for incoming request.
func (r ApiGetannouncementRequest) Eids(eids []int64) ApiGetannouncementRequest {
	r.eids = &eids
	return r
}

func (r ApiGetannouncementRequest) Execute() (*GetAnnouncementResponse, *http.Response, error) {
	return r.ApiService.GetannouncementExecute(r)
}

/*
Getannouncement Read announcement details.

Gets a announcement given its ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetannouncementRequest
*/
func (a *AnnouncementsApiService) Getannouncement(ctx context.Context) ApiGetannouncementRequest {
	return ApiGetannouncementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAnnouncementResponse
func (a *AnnouncementsApiService) GetannouncementExecute(r ApiGetannouncementRequest) (*GetAnnouncementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAnnouncementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnouncementsApiService.Getannouncement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getannouncement"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	if r.actas != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actas", r.actas, "")
	}
	if r.clientVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientVersion", r.clientVersion, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.eids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eids", r.eids, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetdraftannouncementRequest struct {
	ctx context.Context
	ApiService *AnnouncementsApiService
	payload *GetAnnouncementRequest
	actas *string
	clientVersion *string
	domain *string
	eids *[]int64
}

// Get draft announcement request
func (r ApiGetdraftannouncementRequest) Payload(payload GetAnnouncementRequest) ApiGetdraftannouncementRequest {
	r.payload = &payload
	return r
}

// Email of another user to act as for debugging purposes. Requires sufficient permissions.
func (r ApiGetdraftannouncementRequest) Actas(actas string) ApiGetdraftannouncementRequest {
	r.actas = &actas
	return r
}

// The version of the client making the request.
func (r ApiGetdraftannouncementRequest) ClientVersion(clientVersion string) ApiGetdraftannouncementRequest {
	r.clientVersion = &clientVersion
	return r
}

// The domain of the top-level page in which the client is being run. For embedded search and NSR, it will be the domain of the embedding page. For sidebar, it will be the domain of the embedding page if it&#39;s a recognized workplace app. For NTP and app.glean.com requests, it will be empty.
func (r ApiGetdraftannouncementRequest) Domain(domain string) ApiGetdraftannouncementRequest {
	r.domain = &domain
	return r
}

// List of experiment ids to force for incoming request.
func (r ApiGetdraftannouncementRequest) Eids(eids []int64) ApiGetdraftannouncementRequest {
	r.eids = &eids
	return r
}

func (r ApiGetdraftannouncementRequest) Execute() (*GetDraftAnnouncementResponse, *http.Response, error) {
	return r.ApiService.GetdraftannouncementExecute(r)
}

/*
Getdraftannouncement Get draft announcement

Gets an existing user-generated draft announcement.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetdraftannouncementRequest
*/
func (a *AnnouncementsApiService) Getdraftannouncement(ctx context.Context) ApiGetdraftannouncementRequest {
	return ApiGetdraftannouncementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetDraftAnnouncementResponse
func (a *AnnouncementsApiService) GetdraftannouncementExecute(r ApiGetdraftannouncementRequest) (*GetDraftAnnouncementResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDraftAnnouncementResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnouncementsApiService.Getdraftannouncement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getdraftannouncement"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	if r.actas != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actas", r.actas, "")
	}
	if r.clientVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientVersion", r.clientVersion, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.eids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eids", r.eids, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListannouncementsRequest struct {
	ctx context.Context
	ApiService *AnnouncementsApiService
	payload *ListAnnouncementsRequest
	actas *string
	clientVersion *string
	domain *string
	eids *[]int64
}

// Includes request params for querying announcements.
func (r ApiListannouncementsRequest) Payload(payload ListAnnouncementsRequest) ApiListannouncementsRequest {
	r.payload = &payload
	return r
}

// Email of another user to act as for debugging purposes. Requires sufficient permissions.
func (r ApiListannouncementsRequest) Actas(actas string) ApiListannouncementsRequest {
	r.actas = &actas
	return r
}

// The version of the client making the request.
func (r ApiListannouncementsRequest) ClientVersion(clientVersion string) ApiListannouncementsRequest {
	r.clientVersion = &clientVersion
	return r
}

// The domain of the top-level page in which the client is being run. For embedded search and NSR, it will be the domain of the embedding page. For sidebar, it will be the domain of the embedding page if it&#39;s a recognized workplace app. For NTP and app.glean.com requests, it will be empty.
func (r ApiListannouncementsRequest) Domain(domain string) ApiListannouncementsRequest {
	r.domain = &domain
	return r
}

// List of experiment ids to force for incoming request.
func (r ApiListannouncementsRequest) Eids(eids []int64) ApiListannouncementsRequest {
	r.eids = &eids
	return r
}

func (r ApiListannouncementsRequest) Execute() (*ListAnnouncementsResponse, *http.Response, error) {
	return r.ApiService.ListannouncementsExecute(r)
}

/*
Listannouncements List announcements

Returns the information to be rendered in announcements dashboard. Includes information for each annoucement asked.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListannouncementsRequest
*/
func (a *AnnouncementsApiService) Listannouncements(ctx context.Context) ApiListannouncementsRequest {
	return ApiListannouncementsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListAnnouncementsResponse
func (a *AnnouncementsApiService) ListannouncementsExecute(r ApiListannouncementsRequest) (*ListAnnouncementsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAnnouncementsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnouncementsApiService.Listannouncements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/listannouncements"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	if r.actas != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actas", r.actas, "")
	}
	if r.clientVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientVersion", r.clientVersion, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.eids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eids", r.eids, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPreviewannouncementRequest struct {
	ctx context.Context
	ApiService *AnnouncementsApiService
	payload *PreviewStructuredTextRequest
	actas *string
	clientVersion *string
	domain *string
	eids *[]int64
}

// preview structured text request
func (r ApiPreviewannouncementRequest) Payload(payload PreviewStructuredTextRequest) ApiPreviewannouncementRequest {
	r.payload = &payload
	return r
}

// Email of another user to act as for debugging purposes. Requires sufficient permissions.
func (r ApiPreviewannouncementRequest) Actas(actas string) ApiPreviewannouncementRequest {
	r.actas = &actas
	return r
}

// The version of the client making the request.
func (r ApiPreviewannouncementRequest) ClientVersion(clientVersion string) ApiPreviewannouncementRequest {
	r.clientVersion = &clientVersion
	return r
}

// The domain of the top-level page in which the client is being run. For embedded search and NSR, it will be the domain of the embedding page. For sidebar, it will be the domain of the embedding page if it&#39;s a recognized workplace app. For NTP and app.glean.com requests, it will be empty.
func (r ApiPreviewannouncementRequest) Domain(domain string) ApiPreviewannouncementRequest {
	r.domain = &domain
	return r
}

// List of experiment ids to force for incoming request.
func (r ApiPreviewannouncementRequest) Eids(eids []int64) ApiPreviewannouncementRequest {
	r.eids = &eids
	return r
}

func (r ApiPreviewannouncementRequest) Execute() (*PreviewStructuredTextResponse, *http.Response, error) {
	return r.ApiService.PreviewannouncementExecute(r)
}

/*
Previewannouncement Preview announcement

Generates a preview for a user-generated announcement from structured text.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPreviewannouncementRequest
*/
func (a *AnnouncementsApiService) Previewannouncement(ctx context.Context) ApiPreviewannouncementRequest {
	return ApiPreviewannouncementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PreviewStructuredTextResponse
func (a *AnnouncementsApiService) PreviewannouncementExecute(r ApiPreviewannouncementRequest) (*PreviewStructuredTextResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PreviewStructuredTextResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnouncementsApiService.Previewannouncement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/previewannouncement"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	if r.actas != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actas", r.actas, "")
	}
	if r.clientVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientVersion", r.clientVersion, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.eids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eids", r.eids, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPreviewannouncementdraftRequest struct {
	ctx context.Context
	ApiService *AnnouncementsApiService
	payload *PreviewUgcRequest
	actas *string
	clientVersion *string
	domain *string
	eids *[]int64
}

// preview announcement request
func (r ApiPreviewannouncementdraftRequest) Payload(payload PreviewUgcRequest) ApiPreviewannouncementdraftRequest {
	r.payload = &payload
	return r
}

// Email of another user to act as for debugging purposes. Requires sufficient permissions.
func (r ApiPreviewannouncementdraftRequest) Actas(actas string) ApiPreviewannouncementdraftRequest {
	r.actas = &actas
	return r
}

// The version of the client making the request.
func (r ApiPreviewannouncementdraftRequest) ClientVersion(clientVersion string) ApiPreviewannouncementdraftRequest {
	r.clientVersion = &clientVersion
	return r
}

// The domain of the top-level page in which the client is being run. For embedded search and NSR, it will be the domain of the embedding page. For sidebar, it will be the domain of the embedding page if it&#39;s a recognized workplace app. For NTP and app.glean.com requests, it will be empty.
func (r ApiPreviewannouncementdraftRequest) Domain(domain string) ApiPreviewannouncementdraftRequest {
	r.domain = &domain
	return r
}

// List of experiment ids to force for incoming request.
func (r ApiPreviewannouncementdraftRequest) Eids(eids []int64) ApiPreviewannouncementdraftRequest {
	r.eids = &eids
	return r
}

func (r ApiPreviewannouncementdraftRequest) Execute() (*PreviewUgcResponse, *http.Response, error) {
	return r.ApiService.PreviewannouncementdraftExecute(r)
}

/*
Previewannouncementdraft Preview announcement

Generates a preview for a user-generated announcement from a draft.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPreviewannouncementdraftRequest
*/
func (a *AnnouncementsApiService) Previewannouncementdraft(ctx context.Context) ApiPreviewannouncementdraftRequest {
	return ApiPreviewannouncementdraftRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PreviewUgcResponse
func (a *AnnouncementsApiService) PreviewannouncementdraftExecute(r ApiPreviewannouncementdraftRequest) (*PreviewUgcResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PreviewUgcResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnouncementsApiService.Previewannouncementdraft")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/previewannouncementdraft"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	if r.actas != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actas", r.actas, "")
	}
	if r.clientVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientVersion", r.clientVersion, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.eids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eids", r.eids, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPublishdraftannouncementRequest struct {
	ctx context.Context
	ApiService *AnnouncementsApiService
	payload *PublishDraftAnnouncementRequest
	actas *string
	clientVersion *string
	domain *string
	eids *[]int64
}

// Publish draft announcement content.
func (r ApiPublishdraftannouncementRequest) Payload(payload PublishDraftAnnouncementRequest) ApiPublishdraftannouncementRequest {
	r.payload = &payload
	return r
}

// Email of another user to act as for debugging purposes. Requires sufficient permissions.
func (r ApiPublishdraftannouncementRequest) Actas(actas string) ApiPublishdraftannouncementRequest {
	r.actas = &actas
	return r
}

// The version of the client making the request.
func (r ApiPublishdraftannouncementRequest) ClientVersion(clientVersion string) ApiPublishdraftannouncementRequest {
	r.clientVersion = &clientVersion
	return r
}

// The domain of the top-level page in which the client is being run. For embedded search and NSR, it will be the domain of the embedding page. For sidebar, it will be the domain of the embedding page if it&#39;s a recognized workplace app. For NTP and app.glean.com requests, it will be empty.
func (r ApiPublishdraftannouncementRequest) Domain(domain string) ApiPublishdraftannouncementRequest {
	r.domain = &domain
	return r
}

// List of experiment ids to force for incoming request.
func (r ApiPublishdraftannouncementRequest) Eids(eids []int64) ApiPublishdraftannouncementRequest {
	r.eids = &eids
	return r
}

func (r ApiPublishdraftannouncementRequest) Execute() (*http.Response, error) {
	return r.ApiService.PublishdraftannouncementExecute(r)
}

/*
Publishdraftannouncement Publish a draft announcement

Promotes a draft announcement to be visible to others.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPublishdraftannouncementRequest
*/
func (a *AnnouncementsApiService) Publishdraftannouncement(ctx context.Context) ApiPublishdraftannouncementRequest {
	return ApiPublishdraftannouncementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AnnouncementsApiService) PublishdraftannouncementExecute(r ApiPublishdraftannouncementRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnouncementsApiService.Publishdraftannouncement")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/publishdraftannouncement"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return nil, reportError("payload is required and must be specified")
	}

	if r.actas != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actas", r.actas, "")
	}
	if r.clientVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientVersion", r.clientVersion, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.eids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eids", r.eids, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUnpublishannouncementRequest struct {
	ctx context.Context
	ApiService *AnnouncementsApiService
	payload *UnpublishAnnouncementRequest
	actas *string
	clientVersion *string
	domain *string
	eids *[]int64
}

// Unpublish announcement content.
func (r ApiUnpublishannouncementRequest) Payload(payload UnpublishAnnouncementRequest) ApiUnpublishannouncementRequest {
	r.payload = &payload
	return r
}

// Email of another user to act as for debugging purposes. Requires sufficient permissions.
func (r ApiUnpublishannouncementRequest) Actas(actas string) ApiUnpublishannouncementRequest {
	r.actas = &actas
	return r
}

// The version of the client making the request.
func (r ApiUnpublishannouncementRequest) ClientVersion(clientVersion string) ApiUnpublishannouncementRequest {
	r.clientVersion = &clientVersion
	return r
}

// The domain of the top-level page in which the client is being run. For embedded search and NSR, it will be the domain of the embedding page. For sidebar, it will be the domain of the embedding page if it&#39;s a recognized workplace app. For NTP and app.glean.com requests, it will be empty.
func (r ApiUnpublishannouncementRequest) Domain(domain string) ApiUnpublishannouncementRequest {
	r.domain = &domain
	return r
}

// List of experiment ids to force for incoming request.
func (r ApiUnpublishannouncementRequest) Eids(eids []int64) ApiUnpublishannouncementRequest {
	r.eids = &eids
	return r
}

func (r ApiUnpublishannouncementRequest) Execute() (*Announcement, *http.Response, error) {
	return r.ApiService.UnpublishannouncementExecute(r)
}

/*
Unpublishannouncement Unpublishes an announcement

Unpublishes an announcement and hides it from users

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUnpublishannouncementRequest
*/
func (a *AnnouncementsApiService) Unpublishannouncement(ctx context.Context) ApiUnpublishannouncementRequest {
	return ApiUnpublishannouncementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Announcement
func (a *AnnouncementsApiService) UnpublishannouncementExecute(r ApiUnpublishannouncementRequest) (*Announcement, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Announcement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnouncementsApiService.Unpublishannouncement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/unpublishannouncement"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	if r.actas != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actas", r.actas, "")
	}
	if r.clientVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientVersion", r.clientVersion, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.eids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eids", r.eids, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateannouncementRequest struct {
	ctx context.Context
	ApiService *AnnouncementsApiService
	payload *UpdateAnnouncementRequest
	actas *string
	clientVersion *string
	domain *string
	eids *[]int64
}

// Announcement content. Id need to be specified for the announcement.
func (r ApiUpdateannouncementRequest) Payload(payload UpdateAnnouncementRequest) ApiUpdateannouncementRequest {
	r.payload = &payload
	return r
}

// Email of another user to act as for debugging purposes. Requires sufficient permissions.
func (r ApiUpdateannouncementRequest) Actas(actas string) ApiUpdateannouncementRequest {
	r.actas = &actas
	return r
}

// The version of the client making the request.
func (r ApiUpdateannouncementRequest) ClientVersion(clientVersion string) ApiUpdateannouncementRequest {
	r.clientVersion = &clientVersion
	return r
}

// The domain of the top-level page in which the client is being run. For embedded search and NSR, it will be the domain of the embedding page. For sidebar, it will be the domain of the embedding page if it&#39;s a recognized workplace app. For NTP and app.glean.com requests, it will be empty.
func (r ApiUpdateannouncementRequest) Domain(domain string) ApiUpdateannouncementRequest {
	r.domain = &domain
	return r
}

// List of experiment ids to force for incoming request.
func (r ApiUpdateannouncementRequest) Eids(eids []int64) ApiUpdateannouncementRequest {
	r.eids = &eids
	return r
}

func (r ApiUpdateannouncementRequest) Execute() (*Announcement, *http.Response, error) {
	return r.ApiService.UpdateannouncementExecute(r)
}

/*
Updateannouncement Update announcement

Updates a textual announcement visible to some set of users based on department and location.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateannouncementRequest
*/
func (a *AnnouncementsApiService) Updateannouncement(ctx context.Context) ApiUpdateannouncementRequest {
	return ApiUpdateannouncementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Announcement
func (a *AnnouncementsApiService) UpdateannouncementExecute(r ApiUpdateannouncementRequest) (*Announcement, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Announcement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnouncementsApiService.Updateannouncement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/updateannouncement"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	if r.actas != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actas", r.actas, "")
	}
	if r.clientVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientVersion", r.clientVersion, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.eids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eids", r.eids, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatedraftannouncementRequest struct {
	ctx context.Context
	ApiService *AnnouncementsApiService
	payload *UpdateDraftAnnouncementRequest
	actas *string
	clientVersion *string
	domain *string
	eids *[]int64
}

// Draft announcement content. DraftId needs to be specified.
func (r ApiUpdatedraftannouncementRequest) Payload(payload UpdateDraftAnnouncementRequest) ApiUpdatedraftannouncementRequest {
	r.payload = &payload
	return r
}

// Email of another user to act as for debugging purposes. Requires sufficient permissions.
func (r ApiUpdatedraftannouncementRequest) Actas(actas string) ApiUpdatedraftannouncementRequest {
	r.actas = &actas
	return r
}

// The version of the client making the request.
func (r ApiUpdatedraftannouncementRequest) ClientVersion(clientVersion string) ApiUpdatedraftannouncementRequest {
	r.clientVersion = &clientVersion
	return r
}

// The domain of the top-level page in which the client is being run. For embedded search and NSR, it will be the domain of the embedding page. For sidebar, it will be the domain of the embedding page if it&#39;s a recognized workplace app. For NTP and app.glean.com requests, it will be empty.
func (r ApiUpdatedraftannouncementRequest) Domain(domain string) ApiUpdatedraftannouncementRequest {
	r.domain = &domain
	return r
}

// List of experiment ids to force for incoming request.
func (r ApiUpdatedraftannouncementRequest) Eids(eids []int64) ApiUpdatedraftannouncementRequest {
	r.eids = &eids
	return r
}

func (r ApiUpdatedraftannouncementRequest) Execute() (*Announcement, *http.Response, error) {
	return r.ApiService.UpdatedraftannouncementExecute(r)
}

/*
Updatedraftannouncement Update draft announcement

Updates a textual announcement visible to some set of users based on department and location.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdatedraftannouncementRequest
*/
func (a *AnnouncementsApiService) Updatedraftannouncement(ctx context.Context) ApiUpdatedraftannouncementRequest {
	return ApiUpdatedraftannouncementRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Announcement
func (a *AnnouncementsApiService) UpdatedraftannouncementExecute(r ApiUpdatedraftannouncementRequest) (*Announcement, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Announcement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AnnouncementsApiService.Updatedraftannouncement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/updatedraftannouncement"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	if r.actas != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actas", r.actas, "")
	}
	if r.clientVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientVersion", r.clientVersion, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.eids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eids", r.eids, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
