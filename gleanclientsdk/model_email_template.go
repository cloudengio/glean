/*
Glean Client API - Platform Preview

# Introduction These are all the APIs used by Glean to implement the Glean client. These are available as platform preview for implementing a custom client to the Glean system.  # Usage guidelines A subset of these endpoints are also in the developer ready section, which is available for public use. The rest of the endpoints are subject to prior agreement with Glean before usage. Please contact support@glean.com if you would like to use an API that is not currently available in the developer ready section. 

API version: 0.9.0
Contact: support@glean.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package gleanclientsdk

import (
	"encoding/json"
	"fmt"
)

// EmailTemplate The type of email to send
type EmailTemplate string

// List of EmailTemplate
const (
	INVITE_TO_SCIO EmailTemplate = "INVITE_TO_SCIO"
	AUTO_INVITE EmailTemplate = "AUTO_INVITE"
	ADMIN_INVITE EmailTemplate = "ADMIN_INVITE"
	TEAMMATE_INVITE EmailTemplate = "TEAMMATE_INVITE"
	INVITE_REMINDER EmailTemplate = "INVITE_REMINDER"
	VERIFICATION_REQUEST EmailTemplate = "VERIFICATION_REQUEST"
	VERIFICATION_REQUEST_NONUSER EmailTemplate = "VERIFICATION_REQUEST_NONUSER"
	SEARCH_FEEDBACK EmailTemplate = "SEARCH_FEEDBACK"
	DOMAIN_VERIFICATION EmailTemplate = "DOMAIN_VERIFICATION"
	RECRAWL_DATASOURCE EmailTemplate = "RECRAWL_DATASOURCE"
	CUSTOM_JSON_REPORT EmailTemplate = "CUSTOM_JSON_REPORT"
	WORKSPACE_INITIALIZED EmailTemplate = "WORKSPACE_INITIALIZED"
)

// All allowed values of EmailTemplate enum
var AllowedEmailTemplateEnumValues = []EmailTemplate{
	"INVITE_TO_SCIO",
	"AUTO_INVITE",
	"ADMIN_INVITE",
	"TEAMMATE_INVITE",
	"INVITE_REMINDER",
	"VERIFICATION_REQUEST",
	"VERIFICATION_REQUEST_NONUSER",
	"SEARCH_FEEDBACK",
	"DOMAIN_VERIFICATION",
	"RECRAWL_DATASOURCE",
	"CUSTOM_JSON_REPORT",
	"WORKSPACE_INITIALIZED",
}

func (v *EmailTemplate) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := EmailTemplate(value)
	for _, existing := range AllowedEmailTemplateEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid EmailTemplate", value)
}

// NewEmailTemplateFromValue returns a pointer to a valid EmailTemplate
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewEmailTemplateFromValue(v string) (*EmailTemplate, error) {
	ev := EmailTemplate(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for EmailTemplate: valid values are %v", v, AllowedEmailTemplateEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v EmailTemplate) IsValid() bool {
	for _, existing := range AllowedEmailTemplateEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to EmailTemplate value
func (v EmailTemplate) Ptr() *EmailTemplate {
	return &v
}

type NullableEmailTemplate struct {
	value *EmailTemplate
	isSet bool
}

func (v NullableEmailTemplate) Get() *EmailTemplate {
	return v.value
}

func (v *NullableEmailTemplate) Set(val *EmailTemplate) {
	v.value = val
	v.isSet = true
}

func (v NullableEmailTemplate) IsSet() bool {
	return v.isSet
}

func (v *NullableEmailTemplate) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableEmailTemplate(val *EmailTemplate) *NullableEmailTemplate {
	return &NullableEmailTemplate{value: val, isSet: true}
}

func (v NullableEmailTemplate) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableEmailTemplate) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

