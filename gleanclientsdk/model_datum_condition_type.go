/*
Glean Client API - Platform Preview

# Introduction These are all the APIs used by Glean to implement the Glean client. These are available as platform preview for implementing a custom client to the Glean system.  # Usage guidelines A subset of these endpoints are also in the developer ready section, which is available for public use. The rest of the endpoints are subject to prior agreement with Glean before usage. Please contact support@glean.com if you would like to use an API that is not currently available in the developer ready section. 

API version: 0.9.0
Contact: support@glean.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package gleanclientsdk

import (
	"encoding/json"
	"fmt"
)

// DatumConditionType the model 'DatumConditionType'
type DatumConditionType string

// List of DatumConditionType
const (
	CHANGES_SINCE_VIEWED DatumConditionType = "CHANGES_SINCE_VIEWED"
	CUSTOM_DATASOURCE DatumConditionType = "CUSTOM_DATASOURCE"
	DATASOURCE_HAS_MULTIPLE_INSTANCES DatumConditionType = "DATASOURCE_HAS_MULTIPLE_INSTANCES"
	EMPTY DatumConditionType = "EMPTY"
	EQUALS DatumConditionType = "EQUALS"
	INSTANCE_HAS_CUSTOM_ICON DatumConditionType = "INSTANCE_HAS_CUSTOM_ICON"
	NONEMPTY DatumConditionType = "NONEMPTY"
	NO_CHANGES_SINCE_VIEWED DatumConditionType = "NO_CHANGES_SINCE_VIEWED"
	STARTS_WITH DatumConditionType = "STARTS_WITH"
	USER_DOMAIN DatumConditionType = "USER_DOMAIN"
)

// All allowed values of DatumConditionType enum
var AllowedDatumConditionTypeEnumValues = []DatumConditionType{
	"CHANGES_SINCE_VIEWED",
	"CUSTOM_DATASOURCE",
	"DATASOURCE_HAS_MULTIPLE_INSTANCES",
	"EMPTY",
	"EQUALS",
	"INSTANCE_HAS_CUSTOM_ICON",
	"NONEMPTY",
	"NO_CHANGES_SINCE_VIEWED",
	"STARTS_WITH",
	"USER_DOMAIN",
}

func (v *DatumConditionType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := DatumConditionType(value)
	for _, existing := range AllowedDatumConditionTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid DatumConditionType", value)
}

// NewDatumConditionTypeFromValue returns a pointer to a valid DatumConditionType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewDatumConditionTypeFromValue(v string) (*DatumConditionType, error) {
	ev := DatumConditionType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for DatumConditionType: valid values are %v", v, AllowedDatumConditionTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v DatumConditionType) IsValid() bool {
	for _, existing := range AllowedDatumConditionTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to DatumConditionType value
func (v DatumConditionType) Ptr() *DatumConditionType {
	return &v
}

type NullableDatumConditionType struct {
	value *DatumConditionType
	isSet bool
}

func (v NullableDatumConditionType) Get() *DatumConditionType {
	return v.value
}

func (v *NullableDatumConditionType) Set(val *DatumConditionType) {
	v.value = val
	v.isSet = true
}

func (v NullableDatumConditionType) IsSet() bool {
	return v.isSet
}

func (v *NullableDatumConditionType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableDatumConditionType(val *DatumConditionType) *NullableDatumConditionType {
	return &NullableDatumConditionType{value: val, isSet: true}
}

func (v NullableDatumConditionType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableDatumConditionType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

