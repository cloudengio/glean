/*
Glean Client API - Platform Preview

# Introduction These are all the APIs used by Glean to implement the Glean client. These are available as platform preview for implementing a custom client to the Glean system.  # Usage guidelines A subset of these endpoints are also in the developer ready section, which is available for public use. The rest of the endpoints are subject to prior agreement with Glean before usage. Please contact support@glean.com if you would like to use an API that is not currently available in the developer ready section. 

API version: 0.9.0
Contact: support@glean.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package gleanclientsdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
)


// ImagesApiService ImagesApi service
type ImagesApiService service

type ApiImagesRequest struct {
	ctx context.Context
	ApiService *ImagesApiService
	key *string
	type_ *ImageType
	id *string
	ds *string
	cid *string
	clientVersion *string
	domain *string
	eids *[]int64
}

// Primary key for the image being asked. The key is returned by the API when an image is uploaded. If key is used, other parameters should not be used.
func (r ApiImagesRequest) Key(key string) ApiImagesRequest {
	r.key = &key
	return r
}

// The type of image requested. Supported values are listed in ImageMetadata.type enum.
func (r ApiImagesRequest) Type_(type_ ImageType) ApiImagesRequest {
	r.type_ = &type_
	return r
}

// ID, if a specific entity/type is requested. The id may have different meaning for each type. for user, it is user id, for UGC, it is the id of the content, and so on.
func (r ApiImagesRequest) Id(id string) ApiImagesRequest {
	r.id = &id
	return r
}

// A specific datasource for which an image is requested for. The ds may have different meaning for each type and can also be empty for some.
func (r ApiImagesRequest) Ds(ds string) ApiImagesRequest {
	r.ds = &ds
	return r
}

// Content id to differentitate multiple images that can have the same type and datasource e.g. thumnail or image from content of UGC. It can also be empty.
func (r ApiImagesRequest) Cid(cid string) ApiImagesRequest {
	r.cid = &cid
	return r
}

// The version of the client making the request.
func (r ApiImagesRequest) ClientVersion(clientVersion string) ApiImagesRequest {
	r.clientVersion = &clientVersion
	return r
}

// The domain of the top-level page in which the client is being run. For embedded search and NSR, it will be the domain of the embedding page. For sidebar, it will be the domain of the embedding page if it&#39;s a recognized workplace app. For NTP and app.glean.com requests, it will be empty.
func (r ApiImagesRequest) Domain(domain string) ApiImagesRequest {
	r.domain = &domain
	return r
}

// List of experiment ids to force for incoming request.
func (r ApiImagesRequest) Eids(eids []int64) ApiImagesRequest {
	r.eids = &eids
	return r
}

func (r ApiImagesRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.ImagesExecute(r)
}

/*
Images Get images

Serves images of various types (profile pic, background, UGC thumnail/content, etc).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiImagesRequest
*/
func (a *ImagesApiService) Images(ctx context.Context) ApiImagesRequest {
	return ApiImagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImagesApiService) ImagesExecute(r ApiImagesRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.Images")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/images"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.key != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.ds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ds", r.ds, "")
	}
	if r.cid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cid", r.cid, "")
	}
	if r.clientVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientVersion", r.clientVersion, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.eids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eids", r.eids, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUploadimageRequest struct {
	ctx context.Context
	ApiService *ImagesApiService
	payload *os.File
	type_ *ImageType
	id *string
	ds *string
	cid *string
	eids *[]int64
	clientVersion *string
	domain *string
	actas *string
}

// Content and metadata for the image. Content is in post body, metada is in url.
func (r ApiUploadimageRequest) Payload(payload *os.File) ApiUploadimageRequest {
	r.payload = payload
	return r
}

// The type of image requested. Supported values are listed in ImageMetadata.type enum.
func (r ApiUploadimageRequest) Type_(type_ ImageType) ApiUploadimageRequest {
	r.type_ = &type_
	return r
}

// ID, if a specific entity/type is requested. The id may have different meaning for each type. For USER, it is user id For UGC, it is the id of the content For ICON, the doctype.
func (r ApiUploadimageRequest) Id(id string) ApiUploadimageRequest {
	r.id = &id
	return r
}

// A specific datasource for which an image is requested for. The ds may have different meaning for each type and can also be empty for some. For USER, it is empty or datasource the icon is asked for. For UGC, it is the UGC datasource. For ICON, it is datasource instance the icon is asked for.
func (r ApiUploadimageRequest) Ds(ds string) ApiUploadimageRequest {
	r.ds = &ds
	return r
}

// Content id to differentitate multiple images that can have the same type and datasource e.g. thumnail or image from content of UGC. It can also be empty.
func (r ApiUploadimageRequest) Cid(cid string) ApiUploadimageRequest {
	r.cid = &cid
	return r
}

// List of experiment ids to force for incoming request.
func (r ApiUploadimageRequest) Eids(eids []int64) ApiUploadimageRequest {
	r.eids = &eids
	return r
}

// The version of the client making the request.
func (r ApiUploadimageRequest) ClientVersion(clientVersion string) ApiUploadimageRequest {
	r.clientVersion = &clientVersion
	return r
}

// The domain of the top-level page in which the client is being run. For embedded search and NSR, it will be the domain of the embedding page. For sidebar, it will be the domain of the embedding page if it&#39;s a recognized workplace app. For NTP and app.glean.com requests, it will be empty.
func (r ApiUploadimageRequest) Domain(domain string) ApiUploadimageRequest {
	r.domain = &domain
	return r
}

// Email of another user to act as for debugging purposes. Requires sufficient permissions.
func (r ApiUploadimageRequest) Actas(actas string) ApiUploadimageRequest {
	r.actas = &actas
	return r
}

func (r ApiUploadimageRequest) Execute() (*UploadImageResponse, *http.Response, error) {
	return r.ApiService.UploadimageExecute(r)
}

/*
Uploadimage upload images

Uploads images for various types (profile pic, background, UGC thumnail/content, etc) with additional metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUploadimageRequest
*/
func (a *ImagesApiService) Uploadimage(ctx context.Context) ApiUploadimageRequest {
	return ApiUploadimageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UploadImageResponse
func (a *ImagesApiService) UploadimageExecute(r ApiUploadimageRequest) (*UploadImageResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UploadImageResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImagesApiService.Uploadimage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/uploadimage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.ds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ds", r.ds, "")
	}
	if r.cid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cid", r.cid, "")
	}
	if r.eids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eids", r.eids, "csv")
	}
	if r.clientVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientVersion", r.clientVersion, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.actas != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actas", r.actas, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"image/*"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
