/*
Glean Client API - Platform Preview

# Introduction These are all the APIs used by Glean to implement the Glean client. These are available as platform preview for implementing a custom client to the Glean system.  # Usage guidelines A subset of these endpoints are also in the developer ready section, which is available for public use. The rest of the endpoints are subject to prior agreement with Glean before usage. Please contact support@glean.com if you would like to use an API that is not currently available in the developer ready section. 

API version: 0.9.0
Contact: support@glean.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package gleanclientsdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// DisplayableListsApiService DisplayableListsApi service
type DisplayableListsApiService service

type ApiCreatedisplayablelistsRequest struct {
	ctx context.Context
	ApiService *DisplayableListsApiService
	payload *CreateDisplayableListsRequest
	clientVersion *string
	domain *string
	eids *[]int64
}

// Create new displayable lists
func (r ApiCreatedisplayablelistsRequest) Payload(payload CreateDisplayableListsRequest) ApiCreatedisplayablelistsRequest {
	r.payload = &payload
	return r
}

// The version of the client making the request.
func (r ApiCreatedisplayablelistsRequest) ClientVersion(clientVersion string) ApiCreatedisplayablelistsRequest {
	r.clientVersion = &clientVersion
	return r
}

// The domain of the top-level page in which the client is being run. For embedded search and NSR, it will be the domain of the embedding page. For sidebar, it will be the domain of the embedding page if it&#39;s a recognized workplace app. For NTP and app.glean.com requests, it will be empty.
func (r ApiCreatedisplayablelistsRequest) Domain(domain string) ApiCreatedisplayablelistsRequest {
	r.domain = &domain
	return r
}

// List of experiment ids to force for incoming request.
func (r ApiCreatedisplayablelistsRequest) Eids(eids []int64) ApiCreatedisplayablelistsRequest {
	r.eids = &eids
	return r
}

func (r ApiCreatedisplayablelistsRequest) Execute() (*CreateDisplayableListsResponse, *http.Response, error) {
	return r.ApiService.CreatedisplayablelistsExecute(r)
}

/*
Createdisplayablelists Create new displayable lists

Create displayable list configurations by provided ids

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreatedisplayablelistsRequest
*/
func (a *DisplayableListsApiService) Createdisplayablelists(ctx context.Context) ApiCreatedisplayablelistsRequest {
	return ApiCreatedisplayablelistsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateDisplayableListsResponse
func (a *DisplayableListsApiService) CreatedisplayablelistsExecute(r ApiCreatedisplayablelistsRequest) (*CreateDisplayableListsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateDisplayableListsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisplayableListsApiService.Createdisplayablelists")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/createdisplayablelists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	if r.clientVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientVersion", r.clientVersion, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.eids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eids", r.eids, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletedisplayablelistsRequest struct {
	ctx context.Context
	ApiService *DisplayableListsApiService
	payload *DeleteDisplayableListsRequest
	clientVersion *string
	domain *string
	eids *[]int64
}

// Updated version of the displayable list configs.
func (r ApiDeletedisplayablelistsRequest) Payload(payload DeleteDisplayableListsRequest) ApiDeletedisplayablelistsRequest {
	r.payload = &payload
	return r
}

// The version of the client making the request.
func (r ApiDeletedisplayablelistsRequest) ClientVersion(clientVersion string) ApiDeletedisplayablelistsRequest {
	r.clientVersion = &clientVersion
	return r
}

// The domain of the top-level page in which the client is being run. For embedded search and NSR, it will be the domain of the embedding page. For sidebar, it will be the domain of the embedding page if it&#39;s a recognized workplace app. For NTP and app.glean.com requests, it will be empty.
func (r ApiDeletedisplayablelistsRequest) Domain(domain string) ApiDeletedisplayablelistsRequest {
	r.domain = &domain
	return r
}

// List of experiment ids to force for incoming request.
func (r ApiDeletedisplayablelistsRequest) Eids(eids []int64) ApiDeletedisplayablelistsRequest {
	r.eids = &eids
	return r
}

func (r ApiDeletedisplayablelistsRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeletedisplayablelistsExecute(r)
}

/*
Deletedisplayablelists Delete displayable lists

Delete displayable list configurations by provided ids

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeletedisplayablelistsRequest
*/
func (a *DisplayableListsApiService) Deletedisplayablelists(ctx context.Context) ApiDeletedisplayablelistsRequest {
	return ApiDeletedisplayablelistsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DisplayableListsApiService) DeletedisplayablelistsExecute(r ApiDeletedisplayablelistsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisplayableListsApiService.Deletedisplayablelists")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deletedisplayablelists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return nil, reportError("payload is required and must be specified")
	}

	if r.clientVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientVersion", r.clientVersion, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.eids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eids", r.eids, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetdisplayablelistsRequest struct {
	ctx context.Context
	ApiService *DisplayableListsApiService
	payload *GetDisplayableListsRequest
	clientVersion *string
	domain *string
	eids *[]int64
	actas *string
}

func (r ApiGetdisplayablelistsRequest) Payload(payload GetDisplayableListsRequest) ApiGetdisplayablelistsRequest {
	r.payload = &payload
	return r
}

// The version of the client making the request.
func (r ApiGetdisplayablelistsRequest) ClientVersion(clientVersion string) ApiGetdisplayablelistsRequest {
	r.clientVersion = &clientVersion
	return r
}

// The domain of the top-level page in which the client is being run. For embedded search and NSR, it will be the domain of the embedding page. For sidebar, it will be the domain of the embedding page if it&#39;s a recognized workplace app. For NTP and app.glean.com requests, it will be empty.
func (r ApiGetdisplayablelistsRequest) Domain(domain string) ApiGetdisplayablelistsRequest {
	r.domain = &domain
	return r
}

// List of experiment ids to force for incoming request.
func (r ApiGetdisplayablelistsRequest) Eids(eids []int64) ApiGetdisplayablelistsRequest {
	r.eids = &eids
	return r
}

// Email of another user to act as for debugging purposes. Requires sufficient permissions.
func (r ApiGetdisplayablelistsRequest) Actas(actas string) ApiGetdisplayablelistsRequest {
	r.actas = &actas
	return r
}

func (r ApiGetdisplayablelistsRequest) Execute() (*GetDisplayableListsResponse, *http.Response, error) {
	return r.ApiService.GetdisplayablelistsExecute(r)
}

/*
Getdisplayablelists Get displayable lists

Get displayable lists configurations by provided ids

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetdisplayablelistsRequest
*/
func (a *DisplayableListsApiService) Getdisplayablelists(ctx context.Context) ApiGetdisplayablelistsRequest {
	return ApiGetdisplayablelistsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetDisplayableListsResponse
func (a *DisplayableListsApiService) GetdisplayablelistsExecute(r ApiGetdisplayablelistsRequest) (*GetDisplayableListsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetDisplayableListsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisplayableListsApiService.Getdisplayablelists")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/getdisplayablelists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	if r.clientVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientVersion", r.clientVersion, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.eids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eids", r.eids, "csv")
	}
	if r.actas != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "actas", r.actas, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatedisplayablelistsRequest struct {
	ctx context.Context
	ApiService *DisplayableListsApiService
	payload *UpdateDisplayableListsRequest
	clientVersion *string
	domain *string
	eids *[]int64
}

// Updated version of the displayable list configs.
func (r ApiUpdatedisplayablelistsRequest) Payload(payload UpdateDisplayableListsRequest) ApiUpdatedisplayablelistsRequest {
	r.payload = &payload
	return r
}

// The version of the client making the request.
func (r ApiUpdatedisplayablelistsRequest) ClientVersion(clientVersion string) ApiUpdatedisplayablelistsRequest {
	r.clientVersion = &clientVersion
	return r
}

// The domain of the top-level page in which the client is being run. For embedded search and NSR, it will be the domain of the embedding page. For sidebar, it will be the domain of the embedding page if it&#39;s a recognized workplace app. For NTP and app.glean.com requests, it will be empty.
func (r ApiUpdatedisplayablelistsRequest) Domain(domain string) ApiUpdatedisplayablelistsRequest {
	r.domain = &domain
	return r
}

// List of experiment ids to force for incoming request.
func (r ApiUpdatedisplayablelistsRequest) Eids(eids []int64) ApiUpdatedisplayablelistsRequest {
	r.eids = &eids
	return r
}

func (r ApiUpdatedisplayablelistsRequest) Execute() (*UpdateDisplayableListsResponse, *http.Response, error) {
	return r.ApiService.UpdatedisplayablelistsExecute(r)
}

/*
Updatedisplayablelists Update displayable lists

Update displayable list configurations with all fields from request fields

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdatedisplayablelistsRequest
*/
func (a *DisplayableListsApiService) Updatedisplayablelists(ctx context.Context) ApiUpdatedisplayablelistsRequest {
	return ApiUpdatedisplayablelistsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UpdateDisplayableListsResponse
func (a *DisplayableListsApiService) UpdatedisplayablelistsExecute(r ApiUpdatedisplayablelistsRequest) (*UpdateDisplayableListsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateDisplayableListsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisplayableListsApiService.Updatedisplayablelists")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/updatedisplayablelists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.payload == nil {
		return localVarReturnValue, nil, reportError("payload is required and must be specified")
	}

	if r.clientVersion != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "clientVersion", r.clientVersion, "")
	}
	if r.domain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "domain", r.domain, "")
	}
	if r.eids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eids", r.eids, "csv")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.payload
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
