/*
Glean Indexing API

# Introduction In addition to the data sources that Glean has built-in support for, Glean also provides a REST API that enables customers to put arbitrary content in the search index. This is useful, for example, for doing permissions-aware search over content in internal tools that reside on-prem as well as for searching over applications that Glean does not currently support first class. In addition these APIs allow the customer to push organization data (people info, organization structure etc) into Glean.  # Early Access Please note that we are continually evolving the system so these APIs are considered “early access” and are subject to change. 

API version: 0.9.0
Contact: support@glean.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package gleansdk

import (
	"encoding/json"
	"fmt"
)

// ConnectorType The source from which document content was pulled, e.g. an API crawl or browser history
type ConnectorType string

// List of ConnectorType
const (
	API_CRAWL ConnectorType = "API_CRAWL"
	BROWSER_CRAWL ConnectorType = "BROWSER_CRAWL"
	BROWSER_HISTORY ConnectorType = "BROWSER_HISTORY"
	BUILTIN ConnectorType = "BUILTIN"
	FEDERATED_SEARCH ConnectorType = "FEDERATED_SEARCH"
	PUSH_API ConnectorType = "PUSH_API"
	WEB_CRAWL ConnectorType = "WEB_CRAWL"
	NATIVE_HISTORY ConnectorType = "NATIVE_HISTORY"
)

// All allowed values of ConnectorType enum
var AllowedConnectorTypeEnumValues = []ConnectorType{
	"API_CRAWL",
	"BROWSER_CRAWL",
	"BROWSER_HISTORY",
	"BUILTIN",
	"FEDERATED_SEARCH",
	"PUSH_API",
	"WEB_CRAWL",
	"NATIVE_HISTORY",
}

func (v *ConnectorType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := ConnectorType(value)
	for _, existing := range AllowedConnectorTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid ConnectorType", value)
}

// NewConnectorTypeFromValue returns a pointer to a valid ConnectorType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewConnectorTypeFromValue(v string) (*ConnectorType, error) {
	ev := ConnectorType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for ConnectorType: valid values are %v", v, AllowedConnectorTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v ConnectorType) IsValid() bool {
	for _, existing := range AllowedConnectorTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to ConnectorType value
func (v ConnectorType) Ptr() *ConnectorType {
	return &v
}

type NullableConnectorType struct {
	value *ConnectorType
	isSet bool
}

func (v NullableConnectorType) Get() *ConnectorType {
	return v.value
}

func (v *NullableConnectorType) Set(val *ConnectorType) {
	v.value = val
	v.isSet = true
}

func (v NullableConnectorType) IsSet() bool {
	return v.isSet
}

func (v *NullableConnectorType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableConnectorType(val *ConnectorType) *NullableConnectorType {
	return &NullableConnectorType{value: val, isSet: true}
}

func (v NullableConnectorType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableConnectorType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

